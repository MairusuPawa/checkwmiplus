
# Get additional ini file configurations and share your configurations 
# at http://www.edcint.co.nz

# This is an ini file for check_wmi_plus.pl - nagios plugin for agentless checking of Windows
#
# Copyright (C) 2011 Matthew Jurgens
# You can email me using: mjurgens (the at goes here) edcint.co.nz
# Download link can be found at http://www.edcint.co.nz

[ini]
# information about the ini file
author=Matthew Jurgens
# ini file version
version=1.3


#==============================================================================
#==============================================================================
#========================= USER DEFINED CHECKS ================================
#==============================================================================
#==============================================================================

#----------------------------------------------------------
[checkio logical]
requires=1.42
inihelp=<<EOT
MODE=checkio, SUBMODE=logical
=============================
   Check logical disk IO. 
   These disks checks use WMI Raw counters to calculate values over a given timeperiod. 
   This is much more accurate than taking Formatted WMI values.
   ARG1: Name of the logical Windows drive to check eg C:. Use % for Wilcard.
      Use _Total to check all drives combined.
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
      
   Note that some of the PercentDisk values seem to give incorrect values. Use with caution.
   This check can return data for multiple drives in a single check.
EOT

# select only one row specific to the disk we are interested in
query=SELECT * FROM Win32_PerfRawData_PerfDisk_LogicalDisk WHERE Name LIKE "{_arg1}"

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_PercentIdleTime,PERF_PRECISION_100NS_TIMER,PercentIdleTime,%.0f,100
customfield=_PercentBusyTime,PERF_PRECISION_100NS_TIMER,PercentIdleTime,%.0f,100,100

# these ones seem to give results over 100%?
customfield=_PercentDiskTime,PERF_PRECISION_100NS_TIMER,PercentDiskTime,%.0f,100
customfield=_PercentDiskReadTime,PERF_PRECISION_100NS_TIMER,PercentDiskReadTime,%.0f,100
customfield=_PercentDiskWriteTime,PERF_PRECISION_100NS_TIMER,PercentDiskWriteTime,%.0f,100

customfield=_DiskReadBytesPersec,PERF_COUNTER_BULK_COUNT,DiskReadBytesPersec,%.0f
customfield=_DiskReadsPersec,PERF_COUNTER_COUNTER,DiskReadsPersec,%.0f
customfield=_DiskWriteBytesPersec,PERF_COUNTER_BULK_COUNT,DiskWriteBytesPersec,%.0f
customfield=_DiskWritesPersec,PERF_COUNTER_COUNTER,DiskWritesPersec,%.0f

# might not work in Server 2003
customfield=_AvgDiskQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskQueueLength,%.1f
customfield=_AvgDiskReadQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskReadQueueLength,%.1f
customfield=_AvgDiskWriteQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskWriteQueueLength,%.1f

test=_PercentIdleTime
test=_PercentBusyTime
test=_PercentDiskTime
test=_PercentDiskReadTime
test=_PercentDiskWriteTime
test=_DiskReadBytesPersec
test=_DiskReadsPersec
test=_DiskWriteBytesPersec
test=_DiskWritesPersec
test=CurrentDiskQueueLength
test=_AvgDiskQueueLength
test=_AvgDiskReadQueueLength
test=_AvgDiskWriteQueueLength

# will show the overall status
predisplay=_DisplayMsg||Overall Status - |~| -||

display=Name||  Logical Drive Name|="| ||"
# will show the status of each item returned
display=_DisplayMsg||~|~| - |(|)
display=_PercentIdleTime|%
display=_PercentBusyTime|%
display=_PercentDiskTime|%
display=_PercentDiskReadTime|%
display=_PercentDiskWriteTime|%
display=_DiskReadBytesPersec|#B/sec
display=_DiskReadsPersec|#/sec
display=_DiskWriteBytesPersec|#B/sec
display=_DiskWritesPersec|#/sec
display=CurrentDiskQueueLength
display=_AvgDiskQueueLength
display=_AvgDiskReadQueueLength
display=_AvgDiskWriteQueueLength

# since this check can return multiple rows at a time (it uses LIKE and % in the WMI query)
# need to include the {Name} so that performance data is unique to each instance
perf=_PercentIdleTime||_PercentIdleTime{Name}
perf=_PercentBusyTime||_PercentBusyTime{Name}
perf=_PercentDiskTime||_PercentDiskTime{Name}
perf=_PercentDiskReadTime||_PercentDiskReadTime{Name}
perf=_PercentDiskWriteTime||_PercentDiskWriteTime{Name}
perf=_DiskReadBytesPersec||_DiskReadBytesPersec{Name}
perf=_DiskReadsPersec||_DiskReadsPersec{Name}
perf=_DiskWriteBytesPersec||_DiskWriteBytesPersec{Name}
perf=_DiskWritesPersec||_DiskWritesPersec{Name}
perf=CurrentDiskQueueLength||CurrentDiskQueueLength{Name}
perf=_AvgDiskQueueLength||_AvgDiskQueueLength{Name}
perf=_AvgDiskReadQueueLength||_AvgDiskReadQueueLength{Name}
perf=_AvgDiskWriteQueueLength||_AvgDiskWriteQueueLength{Name}

#----------------------------------------------------------
[checkio physical]
requires=1.42
inihelp=<<EOT
MODE=checkio, SUBMODE=physical
==============================
   Check physical disk IO. 
   These disks checks use WMI Raw counters to calculate values over a given timeperiod. 
   This is much more accurate than taking Formatted WMI values.
   ARG1: Name of the logical Windows drive to check eg C: Use % for Wilcard.
      Use _Total to check all drives combined.
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
      
   Note that some of the PercentDisk values seem to give incorrect values. Use with caution.
   This check can return data for multiple drives in a single check.
EOT

# select only one row specific to the disk we are interested in
# query needs to include "like" since the physical drive names might not be fully as expected eg "01 C:"
# we automatically include % at the front of the arg1
query=SELECT * FROM Win32_PerfRawData_PerfDisk_PhysicalDisk WHERE Name LIKE "%{_arg1}"

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_PercentIdleTime,PERF_PRECISION_100NS_TIMER,PercentIdleTime,%.0f,100
customfield=_PercentBusyTime,PERF_PRECISION_100NS_TIMER,PercentIdleTime,%.0f,100,100

# these ones seem to give results over 100%?
customfield=_PercentDiskTime,PERF_PRECISION_100NS_TIMER,PercentDiskTime,%.0f,100
customfield=_PercentDiskReadTime,PERF_PRECISION_100NS_TIMER,PercentDiskReadTime,%.0f,100
customfield=_PercentDiskWriteTime,PERF_PRECISION_100NS_TIMER,PercentDiskWriteTime,%.0f,100

customfield=_DiskReadBytesPersec,PERF_COUNTER_BULK_COUNT,DiskReadBytesPersec,%.0f
customfield=_DiskReadsPersec,PERF_COUNTER_COUNTER,DiskReadsPersec,%.0f
customfield=_DiskWriteBytesPersec,PERF_COUNTER_BULK_COUNT,DiskWriteBytesPersec,%.0f
customfield=_DiskWritesPersec,PERF_COUNTER_COUNTER,DiskWritesPersec,%.0f

# might not work in Server 2003
customfield=_AvgDiskQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskQueueLength,%.1f
customfield=_AvgDiskReadQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskReadQueueLength,%.1f
customfield=_AvgDiskWriteQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskWriteQueueLength,%.1f

test=_PercentIdleTime
test=_PercentBusyTime
test=_PercentDiskTime
test=_PercentDiskReadTime
test=_PercentDiskWriteTime
test=_DiskReadBytesPersec
test=_DiskReadsPersec
test=_DiskWriteBytesPersec
test=_DiskWritesPersec
test=CurrentDiskQueueLength
test=_AvgDiskQueueLength
test=_AvgDiskReadQueueLength
test=_AvgDiskWriteQueueLength

# will show the overall status
predisplay=_DisplayMsg||Overall Status - |~| -||

display=Name||  Physical Drive Name|="| ||"
# will show the status of each item returned
display=_DisplayMsg||~|~| - |(|)
display=_PercentIdleTime|%
display=_PercentBusyTime|%
display=_PercentDiskTime|%
display=_PercentDiskReadTime|%
display=_PercentDiskWriteTime|%
display=_DiskReadBytesPersec|#B/sec
display=_DiskReadsPersec|#/sec
display=_DiskWriteBytesPersec|#B/sec
display=_DiskWritesPersec|#/sec
display=CurrentDiskQueueLength
display=_AvgDiskQueueLength
display=_AvgDiskReadQueueLength
display=_AvgDiskWriteQueueLength

# since this check can return multiple rows at a time (it uses LIKE and % in the WMI query)
# need to include the {Name} so that performance data is unique to each instance
perf=_PercentIdleTime||_PercentIdleTime{Name}
perf=_PercentBusyTime||_PercentBusyTime{Name}
perf=_PercentDiskTime||_PercentDiskTime{Name}
perf=_PercentDiskReadTime||_PercentDiskReadTime{Name}
perf=_PercentDiskWriteTime||_PercentDiskWriteTime{Name}
perf=_DiskReadBytesPersec||_DiskReadBytesPersec{Name}
perf=_DiskReadsPersec||_DiskReadsPersec{Name}
perf=_DiskWriteBytesPersec||_DiskWriteBytesPersec{Name}
perf=_DiskWritesPersec||_DiskWritesPersec{Name}
perf=CurrentDiskQueueLength||CurrentDiskQueueLength{Name}
perf=_AvgDiskQueueLength||_AvgDiskQueueLength{Name}
perf=_AvgDiskReadQueueLength||_AvgDiskReadQueueLength{Name}
perf=_AvgDiskWriteQueueLength||_AvgDiskWriteQueueLength{Name}

#----------------------------------------------------------
[checkio old_logical]
requires=1.41
inihelp=<<EOT
MODE=checkio, SUBMODE=old_logical
=================================
   Check logical disk IO. Superseeded by checkio logical.
   ARG1: Name of the logical Windows drive to check eg C:
      Use _Total to check all drives combined.
EOT

# select only one row specific to the disk we are interested in
query=SELECT * FROM Win32_PerfFormattedData_PerfDisk_LogicalDisk WHERE Name="{_arg1}"

test=PercentDiskTime
test=PercentIdleTime
test=PercentDiskReadTime
test=PercentDiskWriteTime
test=DiskReadBytesPersec
test=DiskReadsPersec
test=DiskWriteBytesPersec
test=DiskWritesPersec
test=CurrentDiskQueueLength
test=AvgDiskQueueLength
test=AvgDiskReadQueueLength
test=AvgDiskWriteQueueLength

display=_DisplayMsg||~|~| - ||
display=Name||Logical Drive Name|="|||"
display=PercentDiskTime
display=PercentIdleTime
display=PercentDiskReadTime
display=PercentDiskWriteTime
display=DiskReadBytesPersec
display=DiskReadsPersec
display=DiskWriteBytesPersec
display=DiskWritesPersec
display=CurrentDiskQueueLength
display=AvgDiskQueueLength
display=AvgDiskReadQueueLength
display=AvgDiskWriteQueueLength

perf=PercentDiskTime
perf=PercentIdleTime
perf=PercentDiskReadTime
perf=PercentDiskWriteTime
perf=DiskReadBytesPersec
perf=DiskReadsPersec
perf=DiskWriteBytesPersec
perf=DiskWritesPersec
perf=CurrentDiskQueueLength
perf=AvgDiskQueueLength
perf=AvgDiskReadQueueLength
perf=AvgDiskWriteQueueLength

#----------------------------------------------------------
[checkio old_physical]
requires=1.41
inihelp=<<EOT
MODE=checkio, SUBMODE=old_physical
==================================
   Check physical disk IO. Superseeded by checkio physical.
   ARG1: Name of the physical Windows drive to check eg C: 
      Use _Total to check all drives combined.
EOT

# select only one row specific to the disk we are interested in
# query needs to include "like" since the physical drive names might not be fully as expected eg "01 C:"
query=SELECT * FROM Win32_PerfFormattedData_PerfDisk_PhysicalDisk WHERE Name LIKE "%{_arg1}"

test=PercentDiskTime
test=PercentIdleTime
test=PercentDiskReadTime
test=PercentDiskWriteTime
test=DiskReadBytesPersec
test=DiskReadsPersec
test=DiskWriteBytesPersec
test=DiskWritesPersec
test=CurrentDiskQueueLength
test=AvgDiskQueueLength
test=AvgDiskReadQueueLength
test=AvgDiskWriteQueueLength

display=_DisplayMsg||~|~| - ||
display=Name||Physical Drive Name|="|||"
display=PercentDiskTime
display=PercentIdleTime
display=PercentDiskReadTime
display=PercentDiskWriteTime
display=DiskReadBytesPersec
display=DiskReadsPersec
display=DiskWriteBytesPersec
display=DiskWritesPersec
display=CurrentDiskQueueLength
display=AvgDiskQueueLength
display=AvgDiskReadQueueLength
display=AvgDiskWriteQueueLength

perf=PercentDiskTime
perf=PercentIdleTime
perf=PercentDiskReadTime
perf=PercentDiskWriteTime
perf=DiskReadBytesPersec
perf=DiskReadsPersec
perf=DiskWriteBytesPersec
perf=DiskWritesPersec
perf=CurrentDiskQueueLength
perf=AvgDiskQueueLength
perf=AvgDiskReadQueueLength
perf=AvgDiskWriteQueueLength
#----------------------------------------------------------

#----------------------------------------------------------
[checkproc cmdline]
requires=1.41
inihelp=<<EOT
MODE=checkproc, SUBMODE=cmdline
===============================
   An ini implementation similar to checkprocess. 
   ARG1: The exact command line to search for. Use / instead of \\.
      e.g. C:/WINDOWS/system32/services.exe
   Use -n and/or NODATAEXIT settings to control what happens if no matching process is found
EOT

# we need to convert back / to \ for this one
slashconversion=1

# select only one row specific to the disk we are interested in
query=select Name,CommandLine from Win32_Process WHERE CommandLine = "{_arg1}"

test=_ItemCount

display=_DisplayMsg||~|~| - ||
display=_ItemCount| Instance(s)|Found |~|~|| of "{_arg1}" running.

perf=_ItemCount||Process Count

#----------------------------------------------------------
[checkproc memory]
requires=1.43
inihelp=<<EOT
MODE=checkproc, SUBMODE=memory
===============================
   Check memory details for individual processes
   ARG1: The processname to look for. Use % for wildcards.
      The process name typically only includes the actual file name minus its suffix eg firefox, svchost
      If there are multiple instances eg svchost, then some versions of Windows have them named all the same while others
      such as Windows 2008 Server, have them numbered eg svchost#1, svchost#2, svchost#3. To get all svchost processes you
      need to set ARG1 to svchost%
      To view all processes set ARG1 to "%" and the full process list will be included in the plugin output.
   Use -n and/or NODATAEXIT settings to control what happens if no matching process is found
EOT

# select only one row specific to the disk we are interested in
# I have a feeling that other fields will end up being useful in this query ......
query=select Name,IDProcess,PrivateBytes,VirtualBytes,WorkingSet from Win32_PerfFormattedData_PerfProc_Process WHERE Name like "{_arg1}"

# calculate sums for these fields
calc=PrivateBytes,VirtualBytes,WorkingSet

#createlist=NEWFIELDNAME|LINEDELIM|FIELDDELIM|UNIQUE|FIELD1,FIELD2,etc
# create a list of the process names found
createlist=_ProcessList|),   | (PID=|1|Name,IDProcess

test=_ItemCount
test=_ColSum_PrivateBytes
test=_ColSum_WorkingSet
test=_ColSum_VirtualBytes

display=_DisplayMsg||~|~| - ||
display=_ItemCount| Instance(s)|Found |~|. || of "{_arg1}" running
display=_ColSum_PrivateBytes|#B|Total Private Memory||||
display=_ColSum_WorkingSet|#B|Total Working Set||||
display=_ColSum_VirtualBytes|#B|Total Virtual Memory||~||
display=_ProcessList||\nProcesses Found are |~|~||

# need to include the {Name} so that performance data is unique to each instance
perf=_ItemCount||Process Count
perf=_ColSum_PrivateBytes|Bytes|Total Private Memory
perf=_ColSum_WorkingSet|Bytes|Total Working Set
perf=_ColSum_VirtualBytes|Bytes|Total Virtual Memory

# do not process all individual WMI data rows for warn/critical/display/perfdata
# this is because we are using a createlist to show the processes
processallrows=0

#----------------------------------------------------------
[checkts show]
requires=1.41
inihelp=<<EOT
MODE=checkts, SUBMODE=showsessions
==============================
   Show current Terminal Services Session names. Use this check, normally from the command line, to list the 
   curent session names. Session names are then used in other checkts checks.
EOT

query=SELECT Name FROM Win32_PerfRawData_TermService_TerminalServicesSession

predisplay=_host||Session Name List for |~||| - 
display=Name||~|~|||, 

#----------------------------------------------------------
[checkts sessions]
requires=1.41
inihelp=<<EOT
MODE=checkts, SUBMODE=sessions
==============================
   Check Terminal Services Sessions.
EOT

query=SELECT * FROM Win32_PerfRawData_TermService_TerminalServices

test=ActiveSessions
test=InactiveSessions
test=TotalSessions

display=_DisplayMsg||~|~| - ||
display=ActiveSessions
display=InactiveSessions
display=TotalSessions

perf=ActiveSessions
perf=InactiveSessions
perf=TotalSessions

#----------------------------------------------------------
[checkts sessioninfo]
requires=1.42
inihelp=<<EOT
MODE=checkts, SUBMODE=sessioninfo
=================================
   Check Terminal Services Session Info for specific sessions.
   ARG1: Name of the TS Session eg console
      Note: Not tested on a real terminal services server - you might need to play with this to get what you need.
         Not quite sure what the session names really look like except for "console".
         Please post notes back to www.edcint.co.nz/checkwmiplus to help others. Thanks
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
EOT

query=SELECT * FROM Win32_PerfRawData_TermService_TerminalServicesSession where Name = "{_arg1}"

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

# I suspect some of these fields might be per time figures but the documentation does not say .....
customfield=_InputBytes,PERF_COUNTER_COUNTER,InputBytes,%.0f
customfield=_InputCompressedBytes,PERF_COUNTER_COUNTER,InputCompressedBytes,%.0f
customfield=_OutputBytes,PERF_COUNTER_COUNTER,OutputBytes,%.0f
customfield=_OutputCompressedBytes,PERF_COUNTER_COUNTER,OutputCompressedBytes,%.0f
customfield=_PercentProcessorTime,PERF_100NSEC_TIMER,PercentProcessorTime,%.0f
customfield=_TotalBytes,PERF_COUNTER_COUNTER,TotalBytes,%.0f


test=_InputBytes
test=_InputCompressedBytes
test=InputErrors
test=InputTimeouts
test=_OutputBytes
test=_OutputCompressedBytes
test=OutputErrors
test=OutputTimeouts
test=_PercentProcessorTime
test=PrivateBytes
test=ThreadCount
test=_TotalBytes
test=TotalErrors
test=TotalTimeouts

display=_DisplayMsg||~|~| - ||
display=Name||Session Name|="|||"
display=_InputBytes|#B
display=_InputCompressedBytes|#B
display=InputErrors|#
display=InputTimeouts|#
display=_OutputBytes|#B
display=_OutputCompressedBytes|#B
display=OutputErrors|#
display=OutputTimeouts|#
display=_PercentProcessorTime|%
display=PrivateBytes|#B
display=ThreadCount|#
display=_TotalBytes|#B
display=TotalErrors|#
display=TotalTimeouts|#

perf=_InputBytes
perf=_InputCompressedBytes
perf=InputErrors
perf=InputTimeouts
perf=_OutputBytes
perf=_OutputCompressedBytes
perf=OutputErrors
perf=OutputTimeouts
perf=_PercentProcessorTime
perf=PrivateBytes
perf=ThreadCount
perf=_TotalBytes
perf=TotalErrors
perf=TotalTimeouts


[checkeachcpu]
requires=1.43
inihelp=<<EOT
MODE=checkeachcpu
=================
   Get CPU performance (like checkcpu) but provide information for each CPU. Cores are seen as CPUs. 
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
EOT

query=select PercentProcessorTime,Timestamp_Sys100NS from Win32_PerfRawData_PerfOS_Processor

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_AvgCPU,PERF_100NSEC_TIMER_INV,PercentProcessorTime,%.1f

test=_AvgCPU

# fields to display before we list out all the CPU data
predisplay=_DisplayMsg||~|~| - ||
predisplay=_delay| sec|~|~|~|Average Utilisation (Over approx | period): 

# fields shown per cpu
display=_AvgCPU|%|CPU{Name}||||   

# since this check can return multiple rows at a time (it uses LIKE and % in the WMI query)
# need to include the {Name} so that performance data is unique to each instance
perf=_AvgCPU|%|Avg Utilisation CPU{Name}


#----------------------------------------------------------
[checkdns stats]
requires=1.42
inihelp=<<EOT
MODE=checkdns, SUBMODE=stats
============================
   Checks various stats for Microsoft Windows Server running as a DNS Server
   Tested for Windows Server 2008 R2. Only tested on a low volume server.
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
EOT

# refer http://include.wutils.com/wmi/ROOT%5Ccimv2/CIM_StatisticalInformation/Win32_Perf/Win32_PerfRawData/Win32_PerfRawData_DNS_DNS.html
query=SELECT * FROM Win32_PerfRawData_DNS_DNS

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_DynamicUpdateReceivedPersec,PERF_COUNTER_COUNTER,DynamicUpdateReceivedPersec,%.0f
customfield=_RecursiveQueriesPersec,PERF_COUNTER_COUNTER,RecursiveQueriesPersec,%.0f
customfield=_RecursiveTimeOutPersec,PERF_COUNTER_COUNTER,RecursiveTimeOutPersec,%.0f
customfield=_TotalQueryReceivedPersec,PERF_COUNTER_COUNTER,TotalQueryReceivedPersec,%.0f
customfield=_TCPQueryReceivedPersec,PERF_COUNTER_COUNTER,TCPQueryReceivedPersec,%.0f
customfield=_UDPQueryReceivedPersec,PERF_COUNTER_COUNTER,UDPQueryReceivedPersec,%.0f
customfield=_WINSLookupReceivedPersec,PERF_COUNTER_COUNTER,WINSLookupReceivedPersec,%.0f

test=CachingMemory
test=DatabaseNodeMemory
test=DynamicUpdateReceived
test=_DynamicUpdateReceivedPersec
test=RecursiveQueries
test=_RecursiveQueriesPersec
test=RecursiveQueryFailure
test=_RecursiveTimeOutPersec
test=TotalQueryReceived
test=_TotalQueryReceivedPersec
test=TCPQueryReceived
test=_TCPQueryReceivedPersec
test=UDPQueryReceived
test=_UDPQueryReceivedPersec
test=WINSLookupReceived
test=_WINSLookupReceivedPersec

display=_DisplayMsg||~|~| - ||
display=CachingMemory
display=DatabaseNodeMemory
display=DynamicUpdateReceived
display=_DynamicUpdateReceivedPersec
display=RecursiveQueries
display=_RecursiveQueriesPersec
display=RecursiveQueryFailure
display=_RecursiveTimeOutPersec
display=TotalQueryReceived
display=_TotalQueryReceivedPersec
display=TCPQueryReceived
display=_TCPQueryReceivedPersec
display=UDPQueryReceived
display=_UDPQueryReceivedPersec
display=WINSLookupReceived
display=_WINSLookupReceivedPersec

perf=CachingMemory
perf=DatabaseNodeMemory
perf=DynamicUpdateReceived
perf=_DynamicUpdateReceivedPersec
perf=RecursiveQueries
perf=_RecursiveQueriesPersec
perf=RecursiveQueryFailure
perf=_RecursiveTimeOutPersec
perf=TotalQueryReceived
perf=_TotalQueryReceivedPersec
perf=TCPQueryReceived
perf=_TCPQueryReceivedPersec
perf=UDPQueryReceived
perf=_UDPQueryReceivedPersec
perf=WINSLookupReceived
perf=_WINSLookupReceivedPersec


#----------------------------------------------------------
[checkdhcp stats]
requires=1.42
inihelp=<<EOT
MODE=checkdhcp, SUBMODE=stats
=============================
   Checks various stats for Microsoft Windows Server running as an IPv4 DHCP Server
   Tested for Windows Server 2008 R2. Only tested on a low volume server.
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
EOT

# refer http://include.wutils.com/wmi/ROOT%5Ccimv2/CIM_StatisticalInformation/Win32_Perf/Win32_PerfRawData/Win32_PerfRawData_DNS_DNS.html
query=SELECT * FROM Win32_PerfRawData_DHCPServer_DHCPServer

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_AcksPersec,PERF_COUNTER_COUNTER,AcksPersec,%.1f
customfield=_DeclinesPersec,PERF_COUNTER_COUNTER,DeclinesPersec,%.1f
customfield=_DiscoversPersec,PERF_COUNTER_COUNTER,DiscoversPersec,%.1f
customfield=_OffersPersec,PERF_COUNTER_COUNTER,OffersPersec,%.1f
customfield=_PacketsReceivedPersec,PERF_COUNTER_COUNTER,PacketsReceivedPersec,%.1f
customfield=_ReleasesPersec,PERF_COUNTER_COUNTER,ReleasesPersec,%.1f
customfield=_RequestsPersec,PERF_COUNTER_COUNTER,RequestsPersec,%.1f

test=_AcksPersec
test=ActiveQueueLength
test=ConflictCheckQueueLength
test=Deniedduetomatch
test=Deniedduetononmatch
test=_DeclinesPersec
test=_DiscoversPersec
test=_OffersPersec
test=_PacketsReceivedPersec
test=_ReleasesPersec
test=_RequestsPersec

display=_DisplayMsg||~|~| - ||
display=_AcksPersec
display=ActiveQueueLength
display=ConflictCheckQueueLength
display=Deniedduetomatch
display=Deniedduetononmatch
display=_DeclinesPersec
display=_DiscoversPersec
display=_OffersPersec
display=_PacketsReceivedPersec
display=_ReleasesPersec
display=_RequestsPersec

perf=_AcksPersec
perf=ActiveQueueLength
perf=ConflictCheckQueueLength
perf=Deniedduetomatch
perf=Deniedduetononmatch
perf=_DeclinesPersec
perf=_DiscoversPersec
perf=_OffersPersec
perf=_PacketsReceivedPersec
perf=_ReleasesPersec
perf=_RequestsPersec

#----------------------------------------------------------
[checkdhcpv6 stats]
requires=1.42
inihelp=<<EOT
MODE=checkdhcpv6, SUBMODE=stats
=============================
   Checks various stats for Microsoft Windows Server running as an IPv6 DHCP Server
   Tested for Windows Server 2008 R2. Only tested on a zero volume server!!
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
EOT

# refer http://include.wutils.com/wmi/ROOT%5Ccimv2/CIM_StatisticalInformation/Win32_Perf/Win32_PerfRawData/Win32_PerfRawData_DNS_DNS.html
query=SELECT * FROM Win32_PerfRawData_DHCPServer_DHCPServerv6

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_AcksPersec,PERF_COUNTER_COUNTER,AcksPersec,%.1f
customfield=_ConfirmsPersec,PERF_COUNTER_COUNTER,ConfirmsPersec,%.1f
customfield=_DeclinesPersec,PERF_COUNTER_COUNTER,DeclinesPersec,%.1f
customfield=_PacketsReceivedPersec,PERF_COUNTER_COUNTER,PacketsReceivedPersec,%.1f
customfield=_ReleasesPersec,PERF_COUNTER_COUNTER,ReleasesPersec,%.1f
customfield=_RequestsPersec,PERF_COUNTER_COUNTER,RequestsPersec,%.1f

test=_AcksPersec
test=ActiveQueueLength
test=_ConfirmsPersec
test=_DeclinesPersec
test=_PacketsReceivedPersec
test=_ReleasesPersec
test=_RequestsPersec

display=_DisplayMsg||~|~| - ||
display=_AcksPersec
display=ActiveQueueLength
display=_ConfirmsPersec
display=_DeclinesPersec
display=_PacketsReceivedPersec
display=_ReleasesPersec
display=_RequestsPersec

perf=_AcksPersec
perf=ActiveQueueLength
perf=_ConfirmsPersec
perf=_DeclinesPersec
perf=_PacketsReceivedPersec
perf=_ReleasesPersec
perf=_RequestsPersec


#----------------------------------------------------------
[checkprint spooler]
requires=1.42
inihelp=<<EOT
MODE=print, SUBMODE=spooler
===========================
   Checks various print spooler stats
   Tested for Windows Server 2008 R2. Only tested on a low volume server
   ARG1: The printer queue name to view stats for. Use _Total for the total stats for all print queues.
      Use % for wildcards. The printer queue name can be seen in the Device and Printer screen
      eg "Microsoft XPS Document Writer", "%laser%"
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
   This check can return information about multiple printers in a single check.
EOT

# refer http://msdn.microsoft.com/en-us/library/aa394335%28v=VS.85%29.aspx
query=SELECT * FROM Win32_PerfRawData_Spooler_PrintQueue where Name like "{_arg1}"

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_BytesPrintedPersec,PERF_COUNTER_COUNTER,BytesPrintedPersec,%.0f

test=_BytesPrintedPersec
test=JobErrors
test=Jobs
test=JobsSpooling
test=NotReadyErrors
test=OutofPaperErrors
test=TotalJobsPrinted
test=TotalPagesPrinted

# will show the overall status
predisplay=_DisplayMsg||Overall Status - |~| -||

display=Name||  Printer Name="|~| ||"
# will show the status of each item returned
display=_DisplayMsg||~|~| - |(|)
display=_BytesPrintedPersec
display=JobErrors
display=Jobs
display=JobsSpooling
display=NotReadyErrors
display=OutofPaperErrors
display=TotalJobsPrinted
display=TotalPagesPrinted

# since this check can return multiple rows at a time (it uses LIKE and % in the WMI query)
# need to include the {Name} so that performance data is unique to each instance
perf=_BytesPrintedPersec||{Name} _BytesPrintedPersec
perf=JobErrors||{Name} JobErrors
perf=Jobs||{Name} Jobs
perf=JobsSpooling||{Name} JobsSpooling
perf=NotReadyErrors||{Name} NotReadyErrors
perf=OutofPaperErrors||{Name} OutofPaperErrors
perf=TotalJobsPrinted||{Name} TotalJobsPrinted
perf=TotalPagesPrinted||{Name} TotalPagesPrinted
