
# Get additional ini file configurations and share your configurations 
# at http://www.edcint.co.nz

# This is an ini file for check_wmi_plus.pl - nagios plugin for agentless checking of Windows
#
# Copyright (C) 2011 Matthew Jurgens
# You can email me using: mjurgens (the at goes here) edcint.co.nz
# Download link can be found at http://www.edcint.co.nz

[ini]
# information about the ini file
author=Matthew Jurgens
# ini file version
version=1.2


#==============================================================================
#==============================================================================
#========================= USER DEFINED CHECKS ================================
#==============================================================================
#==============================================================================

#----------------------------------------------------------
[checkio logical]
requires=1.42
inihelp=<<EOT
MODE=checkio, SUBMODE=logical
=============================
   Check logical disk IO. 
   These disks checks use WMI Raw counters to calculate values over a given timeperiod. 
   This is much more accurate than taking Formatted WMI values.
   ARG1: Name of the logical Windows drive to check eg C:
      Use _Total to check all drives combined.
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
      
   Note that some of the PercentDisk values seem to give incorrect values. Use with caution.
EOT

# select only one row specific to the disk we are interested in
query=SELECT * FROM Win32_PerfRawData_PerfDisk_LogicalDisk WHERE Name="{_arg1}"

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_PercentIdleTime,PERF_PRECISION_100NS_TIMER,PercentIdleTime,%.0f,100
customfield=_PercentBusyTime,PERF_PRECISION_100NS_TIMER,PercentIdleTime,%.0f,100,100

# these ones seem to give results over 100%?
customfield=_PercentDiskTime,PERF_PRECISION_100NS_TIMER,PercentDiskTime,%.0f,100
customfield=_PercentDiskReadTime,PERF_PRECISION_100NS_TIMER,PercentDiskReadTime,%.0f,100
customfield=_PercentDiskWriteTime,PERF_PRECISION_100NS_TIMER,PercentDiskWriteTime,%.0f,100

customfield=_DiskReadBytesPersec,PERF_COUNTER_BULK_COUNT,DiskReadBytesPersec,%.0f
customfield=_DiskReadsPersec,PERF_COUNTER_COUNTER,DiskReadsPersec,%.0f
customfield=_DiskWriteBytesPersec,PERF_COUNTER_BULK_COUNT,DiskWriteBytesPersec,%.0f
customfield=_DiskWritesPersec,PERF_COUNTER_COUNTER,DiskWritesPersec,%.0f

# might not work in Server 2003
customfield=_AvgDiskQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskQueueLength,%.1f
customfield=_AvgDiskReadQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskReadQueueLength,%.1f
customfield=_AvgDiskWriteQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskWriteQueueLength,%.1f

test=_PercentIdleTime
test=_PercentBusyTime
test=_PercentDiskTime
test=_PercentDiskReadTime
test=_PercentDiskWriteTime
test=_DiskReadBytesPersec
test=_DiskReadsPersec
test=_DiskWriteBytesPersec
test=_DiskWritesPersec
test=CurrentDiskQueueLength
test=_AvgDiskQueueLength
test=_AvgDiskReadQueueLength
test=_AvgDiskWriteQueueLength

display=_DisplayMsg||~|~| - ||
display=Name||Logical Drive Name|="|||"
display=_PercentIdleTime|%
display=_PercentBusyTime|%
display=_PercentDiskTime|%
display=_PercentDiskReadTime|%
display=_PercentDiskWriteTime|%
display=_DiskReadBytesPersec|#B/sec
display=_DiskReadsPersec|#/sec
display=_DiskWriteBytesPersec|#B/sec
display=_DiskWritesPersec|#/sec
display=CurrentDiskQueueLength
display=_AvgDiskQueueLength
display=_AvgDiskReadQueueLength
display=_AvgDiskWriteQueueLength

perf=_PercentIdleTime
perf=_PercentBusyTime
perf=_PercentDiskTime
perf=_PercentDiskReadTime
perf=_PercentDiskWriteTime
perf=_DiskReadBytesPersec
perf=_DiskReadsPersec
perf=_DiskWriteBytesPersec
perf=_DiskWritesPersec
perf=CurrentDiskQueueLength
perf=_AvgDiskQueueLength
perf=_AvgDiskReadQueueLength
perf=_AvgDiskWriteQueueLength


#----------------------------------------------------------
[checkio physical]
requires=1.42
inihelp=<<EOT
MODE=checkio, SUBMODE=physical
==============================
   Check physical disk IO. 
   These disks checks use WMI Raw counters to calculate values over a given timeperiod. 
   This is much more accurate than taking Formatted WMI values.
   ARG1: Name of the logical Windows drive to check eg C:
      Use _Total to check all drives combined.
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
      
   Note that some of the PercentDisk values seem to give incorrect values. Use with caution.
EOT

# select only one row specific to the disk we are interested in
# query needs to include "like" since the physical drive names might not be fully as expected eg "01 C:"
query=SELECT * FROM Win32_PerfRawData_PerfDisk_PhysicalDisk WHERE Name LIKE "%{_arg1}"

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_PercentIdleTime,PERF_PRECISION_100NS_TIMER,PercentIdleTime,%.0f,100
customfield=_PercentBusyTime,PERF_PRECISION_100NS_TIMER,PercentIdleTime,%.0f,100,100

# these ones seem to give results over 100%?
customfield=_PercentDiskTime,PERF_PRECISION_100NS_TIMER,PercentDiskTime,%.0f,100
customfield=_PercentDiskReadTime,PERF_PRECISION_100NS_TIMER,PercentDiskReadTime,%.0f,100
customfield=_PercentDiskWriteTime,PERF_PRECISION_100NS_TIMER,PercentDiskWriteTime,%.0f,100

customfield=_DiskReadBytesPersec,PERF_COUNTER_BULK_COUNT,DiskReadBytesPersec,%.0f
customfield=_DiskReadsPersec,PERF_COUNTER_COUNTER,DiskReadsPersec,%.0f
customfield=_DiskWriteBytesPersec,PERF_COUNTER_BULK_COUNT,DiskWriteBytesPersec,%.0f
customfield=_DiskWritesPersec,PERF_COUNTER_COUNTER,DiskWritesPersec,%.0f

# might not work in Server 2003
customfield=_AvgDiskQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskQueueLength,%.1f
customfield=_AvgDiskReadQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskReadQueueLength,%.1f
customfield=_AvgDiskWriteQueueLength,PERF_COUNTER_100NS_QUEUELEN_TYPE,AvgDiskWriteQueueLength,%.1f

test=_PercentIdleTime
test=_PercentBusyTime
test=_PercentDiskTime
test=_PercentDiskReadTime
test=_PercentDiskWriteTime
test=_DiskReadBytesPersec
test=_DiskReadsPersec
test=_DiskWriteBytesPersec
test=_DiskWritesPersec
test=CurrentDiskQueueLength
test=_AvgDiskQueueLength
test=_AvgDiskReadQueueLength
test=_AvgDiskWriteQueueLength

display=_DisplayMsg||~|~| - ||
display=Name||Logical Drive Name|="|||"
display=_PercentIdleTime|%
display=_PercentBusyTime|%
display=_PercentDiskTime|%
display=_PercentDiskReadTime|%
display=_PercentDiskWriteTime|%
display=_DiskReadBytesPersec|#B/sec
display=_DiskReadsPersec|#/sec
display=_DiskWriteBytesPersec|#B/sec
display=_DiskWritesPersec|#/sec
display=CurrentDiskQueueLength
display=_AvgDiskQueueLength
display=_AvgDiskReadQueueLength
display=_AvgDiskWriteQueueLength

perf=_PercentIdleTime
perf=_PercentBusyTime
perf=_PercentDiskTime
perf=_PercentDiskReadTime
perf=_PercentDiskWriteTime
perf=_DiskReadBytesPersec
perf=_DiskReadsPersec
perf=_DiskWriteBytesPersec
perf=_DiskWritesPersec
perf=CurrentDiskQueueLength
perf=_AvgDiskQueueLength
perf=_AvgDiskReadQueueLength
perf=_AvgDiskWriteQueueLength

#----------------------------------------------------------
[checkio old_logical]
requires=1.41
inihelp=<<EOT
MODE=checkio, SUBMODE=old_logical
=================================
   Check logical disk IO. Superseeded by checkio logical.
   ARG1: Name of the logical Windows drive to check eg C:
      Use _Total to check all drives combined.
EOT

# select only one row specific to the disk we are interested in
query=SELECT * FROM Win32_PerfFormattedData_PerfDisk_LogicalDisk WHERE Name="{_arg1}"

test=PercentDiskTime
test=PercentIdleTime
test=PercentDiskReadTime
test=PercentDiskWriteTime
test=DiskReadBytesPersec
test=DiskReadsPersec
test=DiskWriteBytesPersec
test=DiskWritesPersec
test=CurrentDiskQueueLength
test=AvgDiskQueueLength
test=AvgDiskReadQueueLength
test=AvgDiskWriteQueueLength

display=_DisplayMsg||~|~| - ||
display=Name||Logical Drive Name|="|||"
display=PercentDiskTime
display=PercentIdleTime
display=PercentDiskReadTime
display=PercentDiskWriteTime
display=DiskReadBytesPersec
display=DiskReadsPersec
display=DiskWriteBytesPersec
display=DiskWritesPersec
display=CurrentDiskQueueLength
display=AvgDiskQueueLength
display=AvgDiskReadQueueLength
display=AvgDiskWriteQueueLength

perf=PercentDiskTime
perf=PercentIdleTime
perf=PercentDiskReadTime
perf=PercentDiskWriteTime
perf=DiskReadBytesPersec
perf=DiskReadsPersec
perf=DiskWriteBytesPersec
perf=DiskWritesPersec
perf=CurrentDiskQueueLength
perf=AvgDiskQueueLength
perf=AvgDiskReadQueueLength
perf=AvgDiskWriteQueueLength

#----------------------------------------------------------
[checkio old_physical]
requires=1.41
inihelp=<<EOT
MODE=checkio, SUBMODE=old_physical
==================================
   Check physical disk IO. Superseeded by checkio physical.
   ARG1: Name of the physical Windows drive to check eg C: 
      Use _Total to check all drives combined.
EOT

# select only one row specific to the disk we are interested in
# query needs to include "like" since the physical drive names might not be fully as expected eg "01 C:"
query=SELECT * FROM Win32_PerfFormattedData_PerfDisk_PhysicalDisk WHERE Name LIKE "%{_arg1}"

test=PercentDiskTime
test=PercentIdleTime
test=PercentDiskReadTime
test=PercentDiskWriteTime
test=DiskReadBytesPersec
test=DiskReadsPersec
test=DiskWriteBytesPersec
test=DiskWritesPersec
test=CurrentDiskQueueLength
test=AvgDiskQueueLength
test=AvgDiskReadQueueLength
test=AvgDiskWriteQueueLength

display=_DisplayMsg||~|~| - ||
display=Name||Physical Drive Name|="|||"
display=PercentDiskTime
display=PercentIdleTime
display=PercentDiskReadTime
display=PercentDiskWriteTime
display=DiskReadBytesPersec
display=DiskReadsPersec
display=DiskWriteBytesPersec
display=DiskWritesPersec
display=CurrentDiskQueueLength
display=AvgDiskQueueLength
display=AvgDiskReadQueueLength
display=AvgDiskWriteQueueLength

perf=PercentDiskTime
perf=PercentIdleTime
perf=PercentDiskReadTime
perf=PercentDiskWriteTime
perf=DiskReadBytesPersec
perf=DiskReadsPersec
perf=DiskWriteBytesPersec
perf=DiskWritesPersec
perf=CurrentDiskQueueLength
perf=AvgDiskQueueLength
perf=AvgDiskReadQueueLength
perf=AvgDiskWriteQueueLength
#----------------------------------------------------------

#----------------------------------------------------------
[checkproc cmdline]
requires=1.41
inihelp=<<EOT
MODE=checkproc, SUBMODE=cmdline
===============================
   An ini implementation similar to checkprocess. 
   ARG1: The exact command line to search for. Use / instead of \\.
      e.g. C:/WINDOWS/system32/services.exe
   Use -n and/or NODATAEXIT settings to control what happens if no matching process is found
EOT

# we need to convert back / to \ for this one
slashconversion=1

# select only one row specific to the disk we are interested in
query=select Name,CommandLine from Win32_Process WHERE CommandLine = "{_arg1}"

test=_ItemCount

display=_DisplayMsg||~|~| - ||
display=_ItemCount| Instance(s)|Found |~|~|| of "{_arg1}" running.

perf=_ItemCount||Process Count

#----------------------------------------------------------
[checkproc memory]
requires=1.43
inihelp=<<EOT
MODE=checkproc, SUBMODE=memory
===============================
   Check memory details for individual processes
   ARG1: The processname to look for. Use % for wildcards.
      The process name typically only includes the actual file name minus its suffix eg firefox, svchost
      If there are multiple instances eg svchost, then some versions of Windows have them named all the same while others
      such as Windows 2008 Server, have them numbered eg svchost#1, svchost#2, svchost#3. To get all svchost processes you
      need to set ARG1 to svchost%
      To view all processes set ARG1 to "%" and the full process list will be included in the plugin output.
   Use -n and/or NODATAEXIT settings to control what happens if no matching process is found
EOT

# select only one row specific to the disk we are interested in
# I have a feeling that other fields will end up being useful in this query ......
query=select Name,IDProcess,PrivateBytes,VirtualBytes,WorkingSet from Win32_PerfFormattedData_PerfProc_Process WHERE Name like "{_arg1}"

# calculate sums for these fields
calc=PrivateBytes,VirtualBytes,WorkingSet

#createlist=NEWFIELDNAME|LINEDELIM|FIELDDELIM|UNIQUE|FIELD1,FIELD2,etc
# create a list of the process names found
createlist=_ProcessList|),   | (PID=|1|Name,IDProcess

test=_ItemCount
test=_ColSum_PrivateBytes
test=_ColSum_WorkingSet
test=_ColSum_VirtualBytes

display=_DisplayMsg||~|~| - ||
display=_ItemCount| Instance(s)|Found |~|. || of "{_arg1}" running
display=_ColSum_PrivateBytes|#B|Total Private Memory||||
display=_ColSum_WorkingSet|#B|Total Working Set||||
display=_ColSum_VirtualBytes|#B|Total Virtual Memory||~||
display=_ProcessList||\nProcesses Found are |~|~||

perf=_ItemCount||Process Count
perf=_ColSum_PrivateBytes|Bytes|Total Private Memory
perf=_ColSum_WorkingSet|Bytes|Total Working Set
perf=_ColSum_VirtualBytes|Bytes|Total Virtual Memory

# do not process all individual WMI data rows for warn/critical/display/perfdata
# this is because we are using a createlist to show the processes
processallrows=0

#----------------------------------------------------------
[checkts sessions]
requires=1.41
inihelp=<<EOT
MODE=checkts, SUBMODE=sessions
==============================
   Check Terminal Services Sessions.
EOT

query=SELECT * FROM Win32_PerfRawData_TermService_TerminalServices

test=ActiveSessions
test=InactiveSessions
test=TotalSessions

display=_DisplayMsg||~|~| - ||
display=ActiveSessions
display=InactiveSessions
display=TotalSessions

perf=ActiveSessions
perf=InactiveSessions
perf=TotalSessions

#----------------------------------------------------------
[checkts sessioninfo]
requires=1.42
inihelp=<<EOT
MODE=checkts, SUBMODE=sessioninfo
=================================
   Check Terminal Services Session Info for specific sessions.
   ARG1: Name of the TS Session eg console
      Note: Not tested on a real terminal services server - you might need to play with this to get what you need.
         Not quite sure what the session names really look like except for "console".
         Please post notes back to www.edcint.co.nz/checkwmiplus to help others. Thanks
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.
EOT

query=SELECT * FROM Win32_PerfRawData_TermService_TerminalServicesSession where Name = "{_arg1}"

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

# I suspect some of these fields might be per time figures but the documentation does not say .....
customfield=_InputBytes,PERF_COUNTER_COUNTER,InputBytes,%.0f
customfield=_InputCompressedBytes,PERF_COUNTER_COUNTER,InputCompressedBytes,%.0f
customfield=_OutputBytes,PERF_COUNTER_COUNTER,OutputBytes,%.0f
customfield=_OutputCompressedBytes,PERF_COUNTER_COUNTER,OutputCompressedBytes,%.0f
customfield=_PercentProcessorTime,PERF_100NSEC_TIMER,PercentProcessorTime,%.0f
customfield=_TotalBytes,PERF_COUNTER_COUNTER,TotalBytes,%.0f


test=_InputBytes
test=_InputCompressedBytes
test=InputErrors
test=InputTimeouts
test=_OutputBytes
test=_OutputCompressedBytes
test=OutputErrors
test=OutputTimeouts
test=_PercentProcessorTime
test=PrivateBytes
test=ThreadCount
test=_TotalBytes
test=TotalErrors
test=TotalTimeouts

display=_DisplayMsg||~|~| - ||
display=Name||Session Name|="|||"
display=_InputBytes|#B
display=_InputCompressedBytes|#B
display=InputErrors|#
display=InputTimeouts|#
display=_OutputBytes|#B
display=_OutputCompressedBytes|#B
display=OutputErrors|#
display=OutputTimeouts|#
display=_PercentProcessorTime|%
display=PrivateBytes|#B
display=ThreadCount|#
display=_TotalBytes|#B
display=TotalErrors|#
display=TotalTimeouts|#

perf=_InputBytes
perf=_InputCompressedBytes
perf=InputErrors
perf=InputTimeouts
perf=_OutputBytes
perf=_OutputCompressedBytes
perf=OutputErrors
perf=OutputTimeouts
perf=_PercentProcessorTime
perf=PrivateBytes
perf=ThreadCount
perf=_TotalBytes
perf=TotalErrors
perf=TotalTimeouts


[checkeachcpu]
requires=1.43
inihelp=<<EOT
MODE=checkeachcpu
=================
   Get CPU performance (like checkcpu) but provide information for each CPU. Cores are seen as CPUs. 
   DELAY: (optional) specifies the number of seconds over which the CPU utilisation is calculated. Default 5.
      The longer you can make this without timing out, the more accurate it will be. if specifying longer values
      you may also need to use the -t parameter to set a longer script timeout.

EOT

query=select PercentProcessorTime,Timestamp_Sys100NS from Win32_PerfRawData_PerfOS_Processor

# run 2 WMI queries, 5 seconds apart
samples=2
delay=5

customfield=_AvgCPU,PERF_100NSEC_TIMER_INV,PercentProcessorTime,%.1f

test=_AvgCPU

# fields to display before we list out all the CPU data
predisplay=_DisplayMsg||~|~| - ||
predisplay=_delay| sec|~|~|~|Average Utilisation (Over approx | period): 

# fields shown per cpu
display=_AvgCPU|%|CPU{Name}||||   

perf=_AvgCPU|%|Avg Utilisation CPU{Name}
